package com.aarves.bluepages.database;

import com.aarves.bluepages.database.access.BookmarkDatabaseDAO;
import com.aarves.bluepages.database.access.LocationDatabaseDAO;
import com.aarves.bluepages.database.models.LocationBasicDataTuple;
import com.aarves.bluepages.database.models.LocationDataEntity;
import com.aarves.bluepages.database.models.LocationDatabaseMapper;

import com.aarves.bluepages.usecase.data.location.LocationDAO;
import com.aarves.bluepages.usecase.data.location.LocationDTO;

import java.util.*;

/**
 * Adapter between the location and bookmark data access objects implemented by Room and the location data access object
 * used by the data access in the use cases layer.
 */
public class LocationDAOAdapter implements LocationDAO {
    /**
     * The precision with which to store the doubles as longs at
     */
    private static final int PRECISION = 14;

    private final BookmarkDatabaseDAO bookmarkDatabaseDAO;
    private final LocationDatabaseDAO locationDatabaseDAO;

    /**
     * Constructs a location adapter with the Room locations and bookmarks data access dependency.
     * @param bookmarkDatabaseDAO the Room data access object for bookmarks in the accounts table
     * @param locationDatabaseDAO the Room data access object for the locations table
     */
    public LocationDAOAdapter(BookmarkDatabaseDAO bookmarkDatabaseDAO, LocationDatabaseDAO locationDatabaseDAO) {
        this.bookmarkDatabaseDAO = bookmarkDatabaseDAO;
        this.locationDatabaseDAO = locationDatabaseDAO;
    }

    /**
     * Adds a new location to the database using the Room data access dependency.
     * @param locationDTO the location data to be added
     * @return the autogenerated ID of the added location
     */
    @Override
    public int addLocation(LocationDTO locationDTO) {
        // Converts location data transfer object to Room data entity
        LocationDataEntity locationDataEntity = LocationDatabaseMapper.mapToDataEntity(locationDTO);
        return (int) this.locationDatabaseDAO.insert(locationDataEntity);
    }

    /**
     * Deletes location from database using the Room data access dependency.
     * @param locationId the ID of the location to be deleted
     */
    @Override
    public void deleteLocation(int locationId) {
        // Retrieves location data entity given ID and deletes it
        LocationDataEntity locationDataEntity = this.locationDatabaseDAO.getByID(locationId);
        this.locationDatabaseDAO.delete(locationDataEntity);
    }

    /**
     * Updates the account with given username's bookmark list using the Room data access dependency.
     * @param username the username of the account to be updated
     * @param bookmarkIds the new list of bookmarked location IDs
     */
    @Override
    public void updateBookmarks(String username, List<Integer> bookmarkIds) {
        this.bookmarkDatabaseDAO.updateBookmarks(username, bookmarkIds);
    }

    /**
     * Retrieves the data of the location with given ID using the Room data access dependency.
     * @param locationId the ID of the location to be retrieved
     * @return the data of the location with given ID, or null if location does not exist
     */
    @Override
    public LocationDTO getLocationData(int locationId) {
        LocationDataEntity locationDataEntity = this.locationDatabaseDAO.getByID(locationId);

        // Converts data entity to data transfer object if not null
        if(locationDataEntity != null) {
            return LocationDatabaseMapper.mapToDTO(locationDataEntity);
        }
        else {
            return null;
        }
    }

    /**
     * Retrieves all the bookmarked locations for account with given username using the Room data access dependency.
     * @param username the username of the account with bookmarks to be retrieved
     * @return a mapping of location IDs to location data of bookmarked locations
     */
    @Override
    public Map<Integer, LocationDTO> getBookmarksData(String username) {
        // Retrieves list of bookmarked location IDs
        List<Integer> bookmarkIds = this.bookmarkDatabaseDAO.getBookmarks(username).bookmarks;
        Map<Integer, LocationDTO> bookmarksData = new HashMap<>();

        // Retrieves location data for each bookmarked location ID
        for(int bookmarkId : bookmarkIds) {
            LocationDTO bookmarkData = this.getLocationData(bookmarkId);

            // Inserts location data only if location exists
            if(bookmarkData != null) {
                bookmarksData.put(bookmarkId, bookmarkData);
            }
        }

        return bookmarksData;
    }

    /**
     * Retrieves a mapping between the coordinates of each location and their IDs using the Room data access dependency.
     * The key will be a list of size 2 with the first element being longitude and the second being latitude.
     * @return a mapping between the coordinates as a list of longs and their IDs
     */
    @Override
    public Map<List<Long>, Integer> getCoordinatesMap() {
        // Gets basic data of all locations from Room data access dependency
        Map<List<Long>, Integer> coordinatesMap = new HashMap<>();
        List<LocationBasicDataTuple> basicDataTuple = this.locationDatabaseDAO.getAllBasicData();

        for(LocationBasicDataTuple basicData : basicDataTuple) {
            // Converts longitude and latitude into list of size 2 with the first element being longitude
            // and the second being latitude, then inserts as key into map
            List<Long> coordinates = Arrays.asList(this.doubleToLong(basicData.longitude), this.doubleToLong(basicData.latitude));
            coordinatesMap.put(coordinates, basicData.locationId);
        }

        return coordinatesMap;
    }

    /**
     * Helper class to convert double to long at given precision.
     * Done to allow for coordinates to be used as key in a map.
     * @param num the double to be converted
     * @return the resulting long
     */
    private long doubleToLong(double num) {
        return (long) (num * Math.pow(10, LocationDAOAdapter.PRECISION));
    }
}
